
#include "PrecompiledHeaders.h"
#include "Toolbox.h"

#include "Compatibility.h"
#include "OrthancException.h"
#include "Logging.h"

#include <json/reader.h>
#include <json/version.h>
#include <json/writer.h>

#if !defined(JSONCPP_VERSION_MAJOR) || !defined(JSONCPP_VERSION_MINOR)
#   error Cannot access the version of JsonCpp
#endif

/**
 * We use deprecated "Json::Reader", "Json::StyledWriter" and
 * "Json::FastWriter" if JsonCpp < 1.7.0. This choice is rather
 * arbitrary, but if Json >= 1.9.0, gcc generates explicit deprecation
 * warnings (clang was warning in earlier versions). For reference,
 * these classes seem to have been deprecated since JsonCpp 1.4.0 (on
 * February 2015) by the following changeset:
 * https://github.com/open-source-parsers/jsoncpp/commit/8df98f6112890d6272734975dd6d70cf8999bb22
 **/
#if (JSONCPP_VERSION_MAJOR >= 2 || (JSONCPP_VERSION_MAJOR == 1 && JSONCPP_VERSION_MINOR >= 8))
#   define JSONCPP_USE_DEPRECATED 0
#else
#   define JSONCPP_USE_DEPRECATED 1
#endif

#include <boost/algorithm/string/case_conv.hpp>
#include <boost/algorithm/string/replace.hpp>
#include <boost/algorithm/string/join.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/regex.hpp>

#if BOOST_VERSION >= 106600
#   include <boost/uuid/detail/sha1.hpp>
#else
#   include <boost/uuid/sha1.hpp>
#endif

#include <string>
#include <stdint.h>
#include <string.h>
#include <algorithm>
#include <ctype.h>

#if ORTHANC_ENABLE_MD5 == 1
// TODO - Could be replaced by <boost/uuid/detail/md5.hpp> starting
// with Boost >= 1.66.0
#   include "../Resources/ThirdParty/md5/md5.h"
#endif

#if ORTHANC_ENABLE_BASE64 == 1
#   include "../Resources/ThirdParty/base64/base64.h"
#endif

#if ORTHANC_ENABLE_LOCALE == 1
#  include <boost/locale.hpp>
#endif

#if ORTHANC_ENABLE_SSL == 1
// For OpenSSL initialization and finalization
#  include <openssl/conf.h>
#  include <openssl/engine.h>
#  include <openssl/err.h>
#  include <openssl/evp.h>
#  include <openssl/ssl.h>

#  if OPENSSL_VERSION_NUMBER < 0x30000000L
#    if defined(_MSC_VER)
#      pragma message("You are linking Orthanc against OpenSSL 1.x, whose license is incompatible with the GPLv3+ used by Orthanc >= 1.10.0. Please update to OpenSSL 3.x, that uses the Apache 2 license.")
#    else
#      warning You are linking Orthanc against OpenSSL 1.x, whose license is incompatible with the GPLv3+ used by Orthanc >= 1.10.0. Please update to OpenSSL 3.x, that uses the Apache 2 license.
#    endif
#  endif

#endif


#if defined(_MSC_VER) && (_MSC_VER < 1800)
// Patch for the missing "_strtoll" symbol when compiling with Visual Studio < 2013
extern "C"
{
  int64_t _strtoi64(const char *nptr, char **endptr, int base);
  int64_t strtoll(const char *nptr, char **endptr, int base)
  {
    return _strtoi64(nptr, endptr, base);
  } 
}
#endif


#if defined(_WIN32)
#  include <windows.h>   // For ::Sleep
#endif


#if ORTHANC_ENABLE_PUGIXML == 1
#  include "ChunkedBuffer.h"
#endif


// Inclusions for UUID
// http://stackoverflow.com/a/1626302

extern "C"
{
#if defined(_WIN32)
#  include <rpc.h>
#else
#  include <uuid/uuid.h>
#endif
}


#if defined(ORTHANC_STATIC_ICU)
#  if (ORTHANC_STATIC_ICU == 1 && ORTHANC_ENABLE_LOCALE == 1)
#    include <OrthancFrameworkResources.h>
#    include <unicode/udata.h>
#    include <unicode/uloc.h>
#    include "Compression/GzipCompressor.h"

static std::string  globalIcuData_;

extern "C"
{
  // This is dummy content for the "icudt58_dat" (resp. "icudt63_dat")
  // global variable from the autogenerated "icudt58l_dat.c"
  // (resp. "icudt63l_dat.c") file that contains a huge C array. In
  // Orthanc, this array is compressed using gzip and attached as a
  // resource, then uncompressed during the launch of Orthanc by
  // static function "InitializeIcu()".
  struct
  {
    double bogus;
    uint8_t *bytes;
  } U_ICUDATA_ENTRY_POINT = { 0.0, NULL };
}

#    if defined(__LSB_VERSION__)
extern "C"
{
  /**
   * The "tzname" global variable is declared as "extern" but is not
   * defined in any compilation module, if using Linux Standard Base,
   * as soon as OpenSSL or cURL is in use on Ubuntu >= 18.04 (glibc >=
   * 2.27). The variable "__tzname" is always properly declared *and*
   * defined. The reason is unclear, and is maybe a bug in the gcc 4.8
   * linker that is used by LSB if facing a weak symbol (as "tzname").
   * This makes Orthanc crash if the timezone is set to UTC.
   * https://groups.google.com/d/msg/orthanc-users/0m8sxxwSm1E/2p8du_89CAAJ
   **/
  char *tzname[2] = { (char *) "GMT", (char *) "GMT" };
}
#    endif

#  endif
#endif
 


#if defined(__unix__) && ORTHANC_SANDBOXED != 1
#  include "SystemToolbox.h"  // Check out "InitializeGlobalLocale()"
#endif


namespace Orthanc
{
    void Toolbox::LinesIterator::FindEndOfLine()
    {
        lineEnd_ = lineStart_;
        while (lineEnd_ < content_.size() &&
               content_[lineEnd_] != '\n' &&
               content_[lineEnd_] != '\r')
        {
            lineEnd_ += 1;
        }
    }

    void Toolbox::LinesIterator::LinesIterator(const std::string& content):
        content_(content),
        lineStart_(0)
    {
        FindEndOfLine();
    }

    bool Toolbox::LinesIterator::GetLine(std::string& target) const
    {
        assert(lineStart_ <= content_.size() &&
               lineEnd_ <= content_.size() &&
               lineStart_ <= lineEnd_);
        if(lineStart_ == content_.size())
        {
            return false;
        }
        else
        {
            target = content_.substr(lineStart_, lineEnd_ - lineStart_);
            return true;
        }
    }

    void Toolbox::LinesIterator::Next()
    {
        lineStart_ = lineEnd_;
        if(lineStart_ != content_.size())
        {
            assert(content_[lineStart_] == '\r' ||
                   content_[lineStart_] == '\n');

            char second;
            if(content_[lineStart_] == '\r')
            {
                second = '\n';
            }
            else
            {
                second = '\r';
            }

            lineStart_ += 1;
            if(lineStart_ < content_.size() && content_[lineStart_] == second)
            {
                lineStart_ += 1;
            }

            FindEndOfLine();
        }
    }

    void Toolbox::ToUpperCase(std::string& s)
    {
        std::transform(s.begin(), s.end(), s.begin(), toupper);
    }

    void Toolbox::ToLowerCase(std::string& s)
    {
        std::transform(s.begin(), s.end(), s.begin(), tolower);
    }

    void Toolbox::ToUpperCase(std::string& result, const std::string& source)
    {
        result = source;
        ToUpperCase(result);
    }

    void Toolbox::ToLowerCase(std::string& result, const std::string& source)
    {
        result = source;
        ToLowerCase(result);
    }

    void Toolbox::SplitUriComponents(UrlComponents& components, const std::string& uri)
    {
        static const char URI_SEPARATOR = '/';
        components.clear();

        if(uri.size == 0 || uri[0] != URI_SEPARATOR)
        {
            throw OrthancException(ErrorCode_UriSyntax);
        }

        //Count the number of slashes in the URI to make an assumption
        // about the number of components in the URI
        unsigned int estimatedSize = 0;
        for(unsigned int i = 0; i < uri.size(); i++)
        {
            if(uri[i] == URI_SEPARATOR)
                estimatedSize++;
        }

        components.reserve(estimatedSize - 1);

        unsigned int start = 1;
        unsigned int end = 1;
        while(end < uri.size())
        {
            // This is the loop invariant
            assert(uri[start - 1] == '/' && (end >= start));

            if(uri[end] == '/')
            {
                components.push_back(std::string(&uri[start], end - start));
                end++;
                start=end;
            }
            else
            {
                end++;
            }
        }

        if(start < uri.size())
        {
            components.push_back(std::string(&uri[start], end - start));
        }

        for(size_t i = 0; i < components.size(); i++)
        {
            if(components[i].size() == 0)
            {
                //Empty component, as in: "/coucou//e"
                throw OrthancException(ErrorCode_UriSyntax);
            }
        }
    }

    void Toolbox::TruncateUri(UriComponents& target, const UriComponents& source, size_t fromLevel)
    {
        target.clear();
        if(source.size() > fromLevel)
        {
            target.resize(source.size() - fromLevel);

            size_t j = 0;
            for(size_t i = fromLevel; i < source.size(); i++, j++)
            {
                target[j] = source[i];
            }

            assert(j == target.size());
        }
    }

    bool Toolbox::IsChildUri(const UriComponents& baseUri, const UriComponents& testedUri)
    {
        if(testedUri.size() < baseUri.size())
        {
            return false;
        }

        for(size_t i = 0; i < baseUri.size(); i++)
        {
            if(baseUri[i] != testedUri[i])
                return false;
        }

        return true;
    }

}