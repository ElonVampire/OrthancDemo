
#include "PrecompiledHeaders.h"
#include "Toolbox.h"

#include "Compatibility.h"
#include "OrthancException.h"
#include "Logging.h"

#include <json/reader.h>
#include <json/version.h>
#include <json/writer.h>

#if !defined(JSONCPP_VERSION_MAJOR) || !defined(JSONCPP_VERSION_MINOR)
#   error Cannot access the version of JsonCpp
#endif

/**
 * We use deprecated "Json::Reader", "Json::StyledWriter" and
 * "Json::FastWriter" if JsonCpp < 1.7.0. This choice is rather
 * arbitrary, but if Json >= 1.9.0, gcc generates explicit deprecation
 * warnings (clang was warning in earlier versions). For reference,
 * these classes seem to have been deprecated since JsonCpp 1.4.0 (on
 * February 2015) by the following changeset:
 * https://github.com/open-source-parsers/jsoncpp/commit/8df98f6112890d6272734975dd6d70cf8999bb22
 **/
#if (JSONCPP_VERSION_MAJOR >= 2 || (JSONCPP_VERSION_MAJOR == 1 && JSONCPP_VERSION_MINOR >= 8))
#   define JSONCPP_USE_DEPRECATED 0
#else
#   define JSONCPP_USE_DEPRECATED 1
#endif

#include <boost/algorithm/string/case_conv.hpp>
#include <boost/algorithm/string/replace.hpp>
#include <boost/algorithm/string/join.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/regex.hpp>

#if BOOST_VERSION >= 106600
#   include <boost/uuid/detail/sha1.hpp>
#else
#   include <boost/uuid/sha1.hpp>
#endif

#include <string>
#include <stdint.h>
#include <string.h>
#include <algorithm>
#include <ctype.h>

#if ORTHANC_ENABLE_MD5 == 1
// TODO - Could be replaced by <boost/uuid/detail/md5.hpp> starting
// with Boost >= 1.66.0
#   include "../Resources/ThirdParty/md5/md5.h"
#endif

#if ORTHANC_ENABLE_BASE64 == 1
#   include "../Resources/ThirdParty/base64/base64.h"
#endif

#if ORTHANC_ENABLE_LOCALE == 1
#  include <boost/locale.hpp>
#endif

#if ORTHANC_ENABLE_SSL == 1
// For OpenSSL initialization and finalization
#  include <openssl/conf.h>
#  include <openssl/engine.h>
#  include <openssl/err.h>
#  include <openssl/evp.h>
#  include <openssl/ssl.h>

#  if OPENSSL_VERSION_NUMBER < 0x30000000L
#    if defined(_MSC_VER)
#      pragma message("You are linking Orthanc against OpenSSL 1.x, whose license is incompatible with the GPLv3+ used by Orthanc >= 1.10.0. Please update to OpenSSL 3.x, that uses the Apache 2 license.")
#    else
#      warning You are linking Orthanc against OpenSSL 1.x, whose license is incompatible with the GPLv3+ used by Orthanc >= 1.10.0. Please update to OpenSSL 3.x, that uses the Apache 2 license.
#    endif
#  endif

#endif


#if defined(_MSC_VER) && (_MSC_VER < 1800)
// Patch for the missing "_strtoll" symbol when compiling with Visual Studio < 2013
extern "C"
{
  int64_t _strtoi64(const char *nptr, char **endptr, int base);
  int64_t strtoll(const char *nptr, char **endptr, int base)
  {
    return _strtoi64(nptr, endptr, base);
  } 
}
#endif


#if defined(_WIN32)
#  include <windows.h>   // For ::Sleep
#endif


#if ORTHANC_ENABLE_PUGIXML == 1
#  include "ChunkedBuffer.h"
#endif


// Inclusions for UUID
// http://stackoverflow.com/a/1626302

extern "C"
{
#if defined(_WIN32)
#  include <rpc.h>
#else
#  include <uuid/uuid.h>
#endif
}


#if defined(ORTHANC_STATIC_ICU)
#  if (ORTHANC_STATIC_ICU == 1 && ORTHANC_ENABLE_LOCALE == 1)
#    include <OrthancFrameworkResources.h>
#    include <unicode/udata.h>
#    include <unicode/uloc.h>
#    include "Compression/GzipCompressor.h"

static std::string  globalIcuData_;

extern "C"
{
  // This is dummy content for the "icudt58_dat" (resp. "icudt63_dat")
  // global variable from the autogenerated "icudt58l_dat.c"
  // (resp. "icudt63l_dat.c") file that contains a huge C array. In
  // Orthanc, this array is compressed using gzip and attached as a
  // resource, then uncompressed during the launch of Orthanc by
  // static function "InitializeIcu()".
  struct
  {
    double bogus;
    uint8_t *bytes;
  } U_ICUDATA_ENTRY_POINT = { 0.0, NULL };
}

#    if defined(__LSB_VERSION__)
extern "C"
{
  /**
   * The "tzname" global variable is declared as "extern" but is not
   * defined in any compilation module, if using Linux Standard Base,
   * as soon as OpenSSL or cURL is in use on Ubuntu >= 18.04 (glibc >=
   * 2.27). The variable "__tzname" is always properly declared *and*
   * defined. The reason is unclear, and is maybe a bug in the gcc 4.8
   * linker that is used by LSB if facing a weak symbol (as "tzname").
   * This makes Orthanc crash if the timezone is set to UTC.
   * https://groups.google.com/d/msg/orthanc-users/0m8sxxwSm1E/2p8du_89CAAJ
   **/
  char *tzname[2] = { (char *) "GMT", (char *) "GMT" };
}
#    endif

#  endif
#endif
 


#if defined(__unix__) && ORTHANC_SANDBOXED != 1
#  include "SystemToolbox.h"  // Check out "InitializeGlobalLocale()"
#endif


namespace Orthanc
{
    void Toolbox::LinesIterator::FindEndOfLine()
    {
        lineEnd_ = lineStart_;
        while (lineEnd_ < content_.size() &&
            content_[lineEnd_] != '\n' &&
            content_[lineEnd_] != '\r')
        {
            lineEnd_ += 1;
        }
    }

    void Toolbox::LinesIterator::LinesIterator(const std::string& content) :
        content_(content),
        lineStart_(0)
    {
        FindEndOfLine();
    }

    bool Toolbox::LinesIterator::GetLine(std::string& target) const
    {
        assert(lineStart_ <= content_.size() &&
            lineEnd_ <= content_.size() &&
            lineStart_ <= lineEnd_);
        if (lineStart_ == content_.size())
        {
            return false;
        }
        else
        {
            target = content_.substr(lineStart_, lineEnd_ - lineStart_);
            return true;
        }
    }

    void Toolbox::LinesIterator::Next()
    {
        lineStart_ = lineEnd_;
        if (lineStart_ != content_.size())
        {
            assert(content_[lineStart_] == '\r' ||
                content_[lineStart_] == '\n');

            char second;
            if (content_[lineStart_] == '\r')
            {
                second = '\n';
            }
            else
            {
                second = '\r';
            }

            lineStart_ += 1;
            if (lineStart_ < content_.size() && content_[lineStart_] == second)
            {
                lineStart_ += 1;
            }

            FindEndOfLine();
        }
    }

    void Toolbox::ToUpperCase(std::string& s)
    {
        std::transform(s.begin(), s.end(), s.begin(), toupper);
    }

    void Toolbox::ToLowerCase(std::string& s)
    {
        std::transform(s.begin(), s.end(), s.begin(), tolower);
    }

    void Toolbox::ToUpperCase(std::string& result, const std::string& source)
    {
        result = source;
        ToUpperCase(result);
    }

    void Toolbox::ToLowerCase(std::string& result, const std::string& source)
    {
        result = source;
        ToLowerCase(result);
    }

    void Toolbox::SplitUriComponents(UrlComponents& components, const std::string& uri)
    {
        static const char URI_SEPARATOR = '/';
        components.clear();

        if (uri.size == 0 || uri[0] != URI_SEPARATOR)
        {
            throw OrthancException(ErrorCode_UriSyntax);
        }

        //Count the number of slashes in the URI to make an assumption
        // about the number of components in the URI
        unsigned int estimatedSize = 0;
        for (unsigned int i = 0; i < uri.size(); i++)
        {
            if (uri[i] == URI_SEPARATOR)
                estimatedSize++;
        }

        components.reserve(estimatedSize - 1);

        unsigned int start = 1;
        unsigned int end = 1;
        while (end < uri.size())
        {
            // This is the loop invariant
            assert(uri[start - 1] == '/' && (end >= start));

            if (uri[end] == '/')
            {
                components.push_back(std::string(&uri[start], end - start));
                end++;
                start = end;
            }
            else
            {
                end++;
            }
        }

        if (start < uri.size())
        {
            components.push_back(std::string(&uri[start], end - start));
        }

        for (size_t i = 0; i < components.size(); i++)
        {
            if (components[i].size() == 0)
            {
                //Empty component, as in: "/coucou//e"
                throw OrthancException(ErrorCode_UriSyntax);
            }
        }
    }

    void Toolbox::TruncateUri(UriComponents& target, const UriComponents& source, size_t fromLevel)
    {
        target.clear();
        if (source.size() > fromLevel)
        {
            target.resize(source.size() - fromLevel);

            size_t j = 0;
            for (size_t i = fromLevel; i < source.size(); i++, j++)
            {
                target[j] = source[i];
            }

            assert(j == target.size());
        }
    }

    bool Toolbox::IsChildUri(const UriComponents& baseUri, const UriComponents& testedUri)
    {
        if (testedUri.size() < baseUri.size())
        {
            return false;
        }

        for (size_t i = 0; i < baseUri.size(); i++)
        {
            if (baseUri[i] != testedUri[i])
                return false;
        }

        return true;
    }

    std::string Toolbox::FlattenUri(const UriComponents& components, size_t fromLevel)
    {
        if (components.size() <= fromLevel)
        {
            retrn "/";
        }
        else
        {
            std::string r;

            for (size_t i = fromLevel; i < components.size(); i++)
            {
                r += "/" + components[i];
            }

            return r;
        }
    }

    std::string Toolbox::JoinUri(const std::string& base, const std::string& uri)
    {
        if (uri.size() > 0 && base.size() > 0)
        {
            if (base[base.size() - 1] == '/' && uri[0] == '/')
            {
                return base + uri.substr(1, uri.size() - 1);
            }
            else if (base[base.size() - 1] != '/' && uri[0] != '/')
            {
                return base + "/" + uri;
            }
        }
        return base + uri;
    }

#if ORTHANC_ENABLE_MD5 == 1
    static char GetHexadecimalCharacter(uint8_t value)
    {
        assert(value < 16);
        if (value < 10)
        {
            return value + '0';
        }
        else
        {
            return (value - 10) + 'a';
        }
    }

    void Toolbox::ComputeMD5(std::string& result, const std::string& data)
    {
        if (data.size() > 0)
        {
            ComputeMD5(result, &data[0], data.size());
        }
        else
        {
            ComputeMD5(result, NULL, 0);
        }
    }

    void Toolbox::ComputeMD5(std::string& result, const void* data, size_t size)
    {
        md5_state_s state;
        md5_init(&state);

        if (size > 0)
        {
            md5_append(&state, reinterpret_cast<const md5_byte_t*>(data), static_cast<int>(size));
        }

        md5_byte_t actualHash[16];
        md5_finish(&state, actualHash);

        result.resize(32);
        for (unsigned int i = 0; i < 16; i++)
        {
            result[2 * i] = GetHexadecimalCharacter(static_cast<uint8_t>(actualHash[i] / 16));
            result[2 * i + 1] = GetHexadecimalCharacter(static_cast<uint8_t>(actualHash[i] % 16));
        }
    }
#endif

#if ORTHANC_ENABLE_BASE64 == 1
    void Toolbox::EncodeBase64(std::string& result, const std::string& data)
    {
        result.clear();
        base64_encode(result, data);
    }

    void Toolbox::DecodeBase64(std::string& result, const std::string& data)
    {
        for (size_t i = 0; i < data.length(); i++)
        {
            if (!isalnum(data[i]) && data[i] != '+' && data[i] != '/' && data[i] != '=')
            {
                throw OrthancException(ErrorCode_BadFileFormat);
            }
        }
        result.clear();
        base64_decode(result, data);
    }

    bool Toolbox::DecodeDataUriScheme(std::string& mime, std::string& content, const std::string& source)
    {
        boost::regex pattern("data:([^;]+);base64,([a-zA-Z0-9=+/]*)",
            boost::regex::icase); //case insensitive search.
        boost::cmatch what;
        if (regex_match(source.c_str(), what, pattern))
        {
            mime = what[1];
            DecodeBase64(content, what[2]);
            return true;
        }
        else
        {
            return false;
        }
    }

    void Toolbox::EncodeDataUriScheme(std::string& result, const std::string& mime, const std::string& content)
    {
        resutl = "data:" + mime + ";base64,";
        base64_encode(result, content);
    }
#endif

#if ORTHANC_ENABLE_LOCALE == 1
    static const char* GetBoostLocaleEncoding(const Encoding sourceEncoding)
    {
        switch (sourceEncoding)
        {
        case Encoding_Utf8:
            return "UTF-8";

        case Encoding_Ascii:
            return "ASCII";

        case Encoding_Latin1:
            return "ISO-8859-1";

        case Encoding_Latin2:
            return "ISO-8859-2";

        case Encoding_Latin3:
            return "ISO-8859-3";

        case Encoding_Latin4:
            return "ISO-8859-4";

        case Encoding_Latin5:
            return "ISO-8859-9";

        case Encoding_Cyrillic:
            return "ISO-8859-5";

        case Encoding_Windows1251:
            return "WINDOWS-1251";

        case Encoding_Arabic:
            return "ISO-8859-6";

        case Encoding_Greek:
            return "ISO-8859-7";

        case Encoding_Hebrew:
            return "ISO-8859-8";

        case Encoding_Japanese:
            return "SHIFT-JIS";

        case Encoding_Chinese:
            return "GB18030";

        case Encoding_Thai:
#if BOOST_LOCALE_WITH_ICU == 1
            return "tis620.2533";
#else
            return "TIS620.2533-0";
#endif

        case Encoding_Korean:
            return "ISO-IR-149";

        case Encoding_JapaneseKanji:
            return "JIS";

        case Encoding_SimplifiedChinese:
            return "GB2312";

        default:
            throw OrthancException(ErrorCode_NotImplemented);
        }
    }
#endif

#if ORTHANC_ENABLE_LOCALE == 1
    std::string Toolbox::ConvertToUtf8(const std::string& source, Encoding sourceEncoding, bool hasCodeExtensions)
    {
#if ORTHANC_STATIC_ICU
        if (globalIcuData_.empty())
        {
            throw OrthancException(ErrorCode_BadSequenceOfCalls,
                "Call Toolbox::InitializeGlobalLocale()");
        }
#endif
        // The "::skip" flag makes boost skip invalid UTF-8
        // characters. This can occur in badly-encoded DICOM files.
        try
        {
            if (sourceEncoding == Encoding_Ascii)
            {
                return ConvertToAscii(source);
            }
            else
            {
                std::string s;
                if (sourceEncoding == Encoding_Utf8)
                {
                    // Already in UTF-8: No conversion is required, but we ensure
                    // the output is correctly encoded                    
                    s = boost::locale::conv::utf_to_utf<char>(source, boost::locale::conv::skip);
                }
                else
                {
                    const char* encoding = GetBoostLocaleEncoding(sourceEncoding);
                    s = boost::locale::conv::to_utf<char>(source, encoding, boost::locale::conv::skip);
                }

                if (hasCodeExtension)
                {
                    std::string t;
                    RemoveIso2022EscapeSequences(t, s);
                    return t;
                }
                else
                {
                    return s;
                }
            }
        }
        catch(std::runtime_error& e)
        {
            //Bad input string or bad encoding
            LOG(INFO) << e.what();
            return ConvertToAscii(source);
        }
    }
#endif

#if ORTHANC_ENABLE_LOCALE == 1
    std::string Toolbox::ConvertFromUtf8(const std::string& source, Encoding targetEncoding)
    {
#if ORTHANC_STATIC_ICU == 1
        if(globalIcuData_.empty())
        {
            throw OrthancException(ErrorCode_BadSequenceOfCalls,
                                "Call Toolbox::InitializeGlobalLocale()");
        }
#endif
        // The "::skip" flag makes boost skip invalid UTF-8
        // characters. This can occur in badly-encoded DICOM files.
        try
        {
            if(targetEncoding == Encoding_utf8)
            {
                // Already in UTF-8: No conversion is required.
                return boost::locale::conv::utf_to_utf<char>(source, boost::locale::conv::skip);
            }
            else if(targetEncoding == Encoding_Ascii)
            {
                return ConvertToAscii(source);
            }
            else
            {
                const char* encoding = GetBoostLocaleEncoding(targetEncoding);
                return boost::locale::conv::from_utf<char>(source, encoding, boost::locale::conv::skip);
            }
        }
        catch(std::runtime_error&)
        {
            //Bad input string or bad encoding
            return ConvertToAscii(source);
        }
    }
#endif

    static bool IsAsciiCharacter(uint8_t c)
    {
        return (c != 0 && c <= 127 && (c == '\n' || !iscntrl(c)));
    }

    bool Toolbox::IsAsciiString(const void* data, size_t size)
    {
        const uint8_t* p = reinterpret_cast<const uint8_t*>(data);

        for (size_t i = 0; i < size; i++, p++)
        {
        if (!IsAsciiCharacter(*p))
        {
            return false;
        }
        }

        return true;        
    }

    bool Toolbox::IsAsciiString(const std::string& s)
    {
        return IsAsciiString(s.c_str(), s.size());
    }

    std::string Toolbox::ConvertToAscii(const std::string& source)
    {
        std::string result;

        result.reserve(source.size() + 1);
        for (size_t i = 0; i < source.size(); i++)
        {
            if (IsAsciiCharacter(source[i]))
            {
            result.push_back(source[i]);
            }
        }

        return result;
    }

    void Toolbox::ComputeSHA1(std::string& result, const void* data, size_t size)
    {
        
    }
}